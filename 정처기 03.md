 <문제 해설> 1. Visitor(방문자) 패턴 <행위 패턴>  - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성함.   분리된 처리 기능은 각 클래스를 방문하여 수행  2. Observer 패턴 <행위 패턴>  - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달.   분산된 시스템 간에 이벤트 생성, 발행(Publish), 이를 수신(Subscribe)해야할 때 이용함  4. Bridge 패턴 <구조 패턴>   - 구현부에서 추상층을 분리, 서로가 독립적으로 확장함    기능과 구현을 두 개의 별도 클래스로 구현함



시퀀스(Sequence) 다이어그램 - 액, 객, 생, 메, 실
: 메시지(함수호출)를 주고받으면서 시간의 흐름에 따라 상호작용하는 과정들(그림으로 표현)
액터(Actor) : 시스템으로부터 서비스를 요청하는 외부요소로, 사람이나 외부 시스템 의미
객체(object) ： 메시지를 주고받는 주체
생명선(Lifeline) ： 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현
메시지(Message) ： 객체가 상호 작용을 위해 주고받는 메시지
실행 상자(Active Box) : 객체가 메시지를 주고받으며 구동되고 있음을 표현



클래스에 대한 여러 가정을 공유하도록 명세한 것을 협약에 의한 설계(Design by Contract)라 함.
소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세를 위하여 선행조건, 결과조건, 불변조건을 나타내는 설계 방법.

협약에 의한 설계의 세 가지 타입
선행조건(precondition): 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
결과조건(postcondition): 오퍼레이션이 수행된 후 만족하여야 하는 조건
불변조건(invariant): 클래스 내부가 실행되는 동안 항상 만족하여야 하는 조건(예: 리스트에 있는 노드가 항상 오름차순으로 되어야 함)



< 행위(Behavioral) 다이어그램 >
\1. 유스케이스(UseCase) 다이어그램
\2. 시퀀스(Sequence) 다이어그램
\3. 커뮤니케이션(Communication) 다이어그램
\4. 상태(State) 다이어그램
\5. 활동(Activity) 다이어그램
\6. 상호작용 개요(Interaction Overview) 다이어그램
\7. 타이밍(Timing) 다이어그램



 <문제 해설> 자료 흐름도 구성 요소 - 프로세스 (Process) - 자료 흐름(Data Flow) - 자료 저장소(Data Store) - 단말(Terminator)



소프트웨어 공학의 자동화를 의미, 소프트웨어 공학작업을 자동화한 소프트웨어 패키지를 CASE도구라고 한다.
CASE도구들은 소프트웨어 관리자들과 실무자들이 소프트웨어 프로세스와 관련된 활동을 지원한다. 즉, 프로젝트 관리 활동을 자동화하고, 결과물을 관리하며, 엔지니어들의 분석, 설계 및 코딩과 테스트작업을 도운다.

주요기능: 다양한 소프트웨어 개발 모형 지원, 그래픽 지원, 소프트웨어 생명주기의 전단계 연결

CASE는 1980년대에 소개되었으며, 1990년대부터 자주 사용되었습니다.

CASE는 객체지향 시스템 뿐만 아니라 구조 시스템등 모든분야에 적용됨



\1. WAS(웹 애플리케이션 서버)
 \- 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리함
 \- 웹 환경을 구현하기 위한 미들웨어

\2. Web Server
  \- 클라이언트로부터 직접 요청을 받아 처리, 저용량의 정적 파일들을 제공하는 소프트웨어

\3. RPC(Remot Procedure Call)
  \- 응용 프로그램이 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어

\4. ORB(Object Request Broker)
  \- 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현함
  \- 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음

TP monitor: 트랜잭션 처리를 감시/제어하는 미들웨어

<행위적 패턴(Behavioral Pattern)>
\1. 책임 연쇄(Chain of Responsibility)
\2. 커맨드 (Command)
\3. 인터프리터(Interpreter)
\4. 반복자(Iterator)
\5. 중재자(Mediator)
\6. 메멘토(Memento)
\7. 옵서버(Observer)
\8. 상태(State)
\9. 전략(Strategy)
\10. 템플릿 메소드(template Method)
\11. 방문자(Visitor)

3번 프로토타입(Prototype) 패턴은 생성 패턴(Creational Pattern)이다.



 <문제 해설> 객체지향 설계원칙  1. 단일 책임 원칙(SRP, Single Responsibility Principle) 객체는 단 하나의 책임만 가져야 한다.  2. 개방-폐쇄의 원칙(OCP, Open Closed Principle) 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.  3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle) 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.  4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle) 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.  5. 의존 역전 원칙(DIP, Dependency Inversion Principle) 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것. 

\1. 연상 코드: 항목의 명칭이나 약호와 관계 있는 숫자, 문자, 기호를 이용하여 코드를 부여하는 방법
\2. 블록 코드: 대상 항목에서 공통적인 것을 블록으로 구분하고 블록 내에 일련 번호를 부여하는 방법
\3. 순차 코드: 일정 기준에 따라 최초의 자료부터 일련번호를 부여하는 방법
\4. 표의 숫자 코드: 길이 넓이 부피 등 항목의 성질의 물리적인 수치를 그대로 코드에 적용시키는 방법

 <문제 해설> 객체지향 분석 방법론

 E-R다이어그램 사용 객체 행위 모델링 및 객체 구조 식별 및 주체 속성 및 관계 서비스 정의 - Coad 와 Yourdon 방법

 클래스와 객체 식별 및 의미 관계 식별 - Booch 방법 

소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링 / 객체모델링 동적 모델링 기능 모델링 - 럼바우(Rumbaugh) 기법 



 Rumbaugh - 가장 일반적으로 사용되는 방법으로 분석 활동을 객체/동적/기능 모델로 나누어 수행하는 방법 Booch - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석방법 Jacobson - Use Case를 강조하여 사용하는 분석방법 Coad와 Yourdon - E-R다이어그램을 사용하여 개체의 활동들을 데이터 모델링하는데 초점을 둔 기법 Wirfs-Brock - : 분석과 설계간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 