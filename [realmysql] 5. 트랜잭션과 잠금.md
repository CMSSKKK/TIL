# 5. 트랜잭션과 잠금

- 잠금 : 동시성을 제어하기 위한 기능
- 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능

### 잠금

MySQL에서 사용되는 잠금은 MySQL 엔진 레벨의 잠금과 스토리지 엔진 레벨의 잠금으로 나눌 수 있다.

MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다.

반면에, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간에 영향을 미치지 않는다.

## 5.2 MySQL 엔진의 잠금

- MySQL 엔진 : 테이블 락(테이블 데이터 동기화), 메타데이터 락(테이블 구조 잠금), 네임드 락(사용자의 필요따라 설정)

### 글로벌 락

- `FLUSH TABLES WITH READ LOCK` 명령으로 획득 가능
- MySQL 제공하는 잠금에서 가장 범위가 큼
- 한 세션에서 글로벌 락을 걸게 되면 다른 세션에서는 select를 제외한 대부분의 DDL, DML 문장은 락의 해제까지 대기함.
- MySQL 전체에 영향을 미침.
- 글로벌 락을 거는 명령을 했을 때, 다른 테이블이나 레코드에 쓰기 잠금이 걸려있다면, 트랜잭션 종료까지 대기
- 또한, 읽기 잠금을 걸기전에 플러쉬를 해야하기 때문에, 모든 종료의 쿼리가 끝나기를 대기해야함
- 가급적 사용하지 않는 것을 권장

### MySQL 8.0 백업락 도입 (가벼운 글로벌 락)

- InnoDB가 기본 스토리지 엔진이 되고, InnoDB가 트랜잭션을 지원함에 따라서 글로벌 락의 필요성이 줄어듬
  - 백업을 위한 가벼운 글로벌 락이 필요해짐
- 한 세션에서 백업 락을 획득한다면?
  - 다른 세션에서는 아래의 명령 및 정보를 변경할 수 없음
    - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경 삭제 
    - REPAIR TABLE, OPTIMIZE TABLE 명령
    - 사용자 관리 및 비밀번호 변경 
  - 일반적인 테이블의 데이터 변경은 허용



### 테이블 락

- 개별 테이블 단위로 설정되는 락, 명시적 또는 묵시적으로 테이블 락 획득 가능
- 명시적 : `LOCK TABLES table_name [ READ : WRITE ]` 
  - 반납 : UNLOCK TABLES
- 묵시적 : MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생 
  - InnoDB에서는 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 묵시적 테이블 락 발생하지 않음
  - 정확히는 테이블 락이 설정되지만, DML은 무시, DDL의 경우에만 영향을 미침

### 네임드 락

- `GET_LCOK()`임의의 문자열에 대해 잠금을 설정할 수 있음
- 단순히 사용자가 지정한 String에 대해서 락을 획득 반납
- 자주 사용되지 않음
- 많은 레코드를 복잡한 요건으로 변경하는 트랜잭션에 사용할 수 있음
  - 배치처럼 한꺼번에 많은 데이터를 변경하는 경우 데드락의 원인이 되는데 네임드 락을 사용하면 간단하게 해결 가능
- 8.0부터 중첩해서 네임드 락을 걸 수 있고, 한 번에 네임드 락을 해제(`RELEASE_ALL_LOCKS()`)할 수 있다. 

### 메타데이터 락

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 묵시적으로 획득
  - 테이블 이름을 변경하는 경우 (`RENAME TABLE table_a TO table_b`)
- `RENAME TABLE rank TO rank_backup, rank_new TO rank;`
- 위의 문장은 문제 없이 작동하지만, 문장을 둘로 나눠서 실행하면, 잠시동안 `Table not found 'rank'` 오류가 생길 수 있다.
- 테이블 구조를 변경하는 경우에 메타데이터 잠금과 트랜잭션을 함께 사용할 수 있음
  - 미리 새로 테이블을 만들어 데이터를 스레드를 이용해서 많이 복사해두고, 트랜잭션을 autocommit으로 실행하고,  rename을 통해서 테이블 명을 바꾼다. (p.166) 

## 5.3 InnoDB 스토리지 엔진 잠금

- 레코드 기반 잠금 방식
  - 이원화된 잠금 처리 탓에 MySQL 명령을 이용해서 잠금에 대한 정보를 얻기 어려웠음
  - 최근 버전에서 `information_schema`데이터 베이스에서,
    - `INNODB_TRX`,`INNODB_LOCKS`, `INNODB_LOCKS_WAITS` 테이블을 조인해서 조회하면 트랜잭션의 잠금 대기, 트랜잭션이 갖고 있는 잠금을 확인할 수 있음
    - 장시간 잠금을 가지는 클라이언트 또한 종료 시킬 수 있음
  - `performance_Schema` 를 이용해서 내부 잠금(세마포어)에 대한 모니터링 방법도 추가되었음

- 다른 DBMS와는 다르게 레코드락뿐만 아니라 레코드와 레코드 사이를 잠그는 **갭(gap) 락**이 존재함

### 레코드 락

- 다른 DBMS와의 차이는 레코드 자체를 잠그는 것이 아니라 인덱스의 레코드를 잠근다는 점
- 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정
- 프라이머리 키 또는 유니크 인덱스에 대한 변경 작업에서는 레코드 자체에 대해서만 락을 설정

### 갭 락

- 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는것을 제어
- 넥스트 키 락의 일부로 자주 사용

### 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- STATEMENT 포맷의 바이너리 로그를 사용하는 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다.
- `Innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면 변경을 위해 검색하는 레코드에 넥스트 키 락 방식으로 잠금
- 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과로 만드는 것을 보장하는 것이 주목적
  - 넥스트 키 락과 갭 락은 데드락 발생 및 트랜잭션을 대기하도록 하는 일이 자주 생김
- 바이너리 로그 포맷 형태를 ROW 형태로 바꾸는 것이 좋음

### 자동 증가 락

- `AUTO_INCREMENT`컬럼은 각 레코드에 대해서 중복되지 않도록 해야하는데, 이 때 발생, 테이블 수준의 잠금
- insert, replace 처럼 새로운 레코드를 저장하는 경우에만 발생
- update, delete 쿼리에서는 발생하지 않음
- Auto_increment 컬럼에 명시적으로 값을 설정해도 락 발생
- 5.1 버전부터는 `innodb_autoinc_lock_mode`시스템 변수를 통해 작동 방식 변경 가능
  - `innodb_autoinc_lock_mode=1`
    - 한 건 또는 레코드 건수를 정확히 예측 가능하면 빠른 래치(뮤텍스) 를 이용해 처리 
    - 여러 개의 자동 증가 값을 할당 받는데, 남는 경우 버려져 연속 증가 값을 얻지 못하는 경우 발생
  - `innodb_autoinc_lock_mode=2`
    - 모든 경우 빠른 래치(뮤텍스) 를 이용해 처리 
    - 유니크한 값만을 보장
- 자동 증가 값이 한번 증가하면 절대 줄어들지 않는 이유가 잠금을 최소화하기 위한 이유
- 8.0 버전 부터 모드 2가 default , 그래서 바이너리 로그 포맷을 statement 형태로 사용할 경우 1을 권장!

### 인덱스와 잠금

- 예제로 Employee 테이블에 first_name 컬럼에는 인덱스를 셋팅, last_name에는 인덱스 셋팅하지 않음
- `update employes set hire_date=now() where first_name= 'george' and last_name='klassen';`
- 위의 쿼리를 실행했을 때, 변경되는 레코드는 하나이지만, 인덱스에 잠금을 하기 때문에, first_name이 george인 모든 레코드에는 락이 걸린다.
- innodb의 인덱스 설계가 중요한 이유