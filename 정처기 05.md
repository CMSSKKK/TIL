데이터 제약조건
개체 무결성 제약 조건 : 기본 키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다.
도메인 무결성 제약 조건 : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다.
참조 무결성 제약 조건 : 외래키의 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다.

데이터 베이스의 논리적 설계(데이터모델링)
-현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정
-개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
-개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계(종속적인 논리 스키마)
-트랜잭션의 인터페이스 설계
-관계형 데이터베이스라면 테이블 설계
-특정목표 DBMS에 따른 스키마설계
-스키마의 평가 및 정제

물리적 설계
-논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환
-데이터 베이스 파일의 저장 구조 및 엑세스 경로 결정
-데이터가 컴퓨터에 저장되는 방법을 묘사
-저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계
-기본적 데이터 단위는 저장레코드
-성능에 중대한 영향을 미침



분산데이터베이스의 목표
-위치투명성(Location Trasparency) 데이터 베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 엑세스할 수 있음
-중복투명성(Replication Transparency) 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것 처럼 사용 가능, 시스템은 자동으로 여러 자료에 대한 작업 수행
-병행투명성(Concurrency Transparency) 다수의 트랜잭션이 동시에 실현되더라도 그 결과는 영향을 받지 않음
-장애투명성(Failure Transparency) 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 트랜잭션을 정확히 처리함.



셀렉트(Select)σ 릴레이션에서 조건을 만족하는 튜플 반환
프로젝트(Project)π 릴레이션에서 주어진 속성들의 값으로만 구성된 튜플 반환
조인(Join)⋈공통 속성을 이용해 두개의 릴레이션 튜플들을 연결해 만들어진 튜플 반환
디비전(Division)÷ [R%S] 릴레이션S의 모든 튜플과 관련있는 릴레이션R의 튜플 반환

셀렉트(Select)σ : 수평적으로 절단하는 것, 행을 다 가져옴
프로젝트(Project)π : 수직적으로 절단하는 것, 열을 선택적으로 가져옴



트랜잭션의 특성

Durability 영속성 : 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
Consistency 일관성 : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
Atomicity 원자성 : 트랜잭션 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
Isolation 격리성 : 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가하다.



1NF 조건 : 원자값으로 구성
2NF 조건 : 부분 함수 종속 제거 (완전 함수적 종속 관계)
3NF 조건 : 이행 함수 종속 제거
BCNF 조건 : 결정자 함수 종속
4NF 조건 : 다중값(다치) 종속성 제거
5NF 조건 : 조인 종속성 제거



뷰는 하나이상의 테이블로부터 유도되는 가상테이블이며 논리적 독립성이 제공됩니다.
실제테이블처럼 권한을 나눌 수 있습니다.

따라서 특정사용자가 볼 필요가 없는 다른열들을 배제하고 뷰를 만든 후 해당 사용자에게 뷰에대한 권한을 할당하면 테이블 전체에 대한 권한을 부여하지 않아도 됩니다.

뷰는 자체적으로 인덱스를 가지지 않습니다. 따라서 삽입 삭제 수정이 제한적인 것입니다.

| 1.   | 뷰 위에 또 다른 뷰를 정의할 수 있다. |
| ---- | ------------------------------------ |
|      |                                      |

| 2.   | 뷰에 대한 조작에서 삽입, 갱신, 삭제 연산은 제약이 따른다. |
| ---- | --------------------------------------------------------- |
|      |                                                           |

| 3.   | 뷰의 정의를 변경하려면 뷰를 삭제하고 재생성해야 한다 |
| ---- | ---------------------------------------------------- |
|      |                                                      |

| 4.   | 뷰가 정의된 기본 테이블이 제거되면 뷰도 자동적으로 제거된다. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |



회복(Recovery)이란
트랜잭션 도중에 손상된 데이터베이스를 이전 상태로 복귀하는 작업
트랙잭션의 연산을 수행할 때 데이터베이스를 변경하기 전에 로그 데이터를 생성합니다.
취소(Undo) 연산으로 이미 데이터베이스에 쓰여진 것도 수정할 수 있습니다.

장애의 유형
트랜잭션 장애, 시스템 장애, 미디어 장애

즉각 갱신 기법(Immediate Update)
트랜잭션의 연산을 수행하여 데이터를 갱신할 때 실제 데이터 베이스에 반영하는 기법
갱신한 모든 내용을 로그(Log)에 보관합니다.
회복 작업을 위해 취소(Undo)와 재시도(Redo) 모두 사용할 수 있습니다.

연기 갱신 기법(Deffered Updatae)
트랜잭션을 완료할 때까지 데이터베이스에 갱신을 연기하는 기법
트랜잭션 수행으로 갱신할 내용은 로그(Log)에 보관합니다.
트랜잭션이 부분 완료 시점에 Log의 기록을 실제 데이터 베이스에 반영합니다.
트랜잭션 수행 중에 장애가 발생하여 Rollback하여도 취소(Undo)할 필요가 없습니다.
재시도(Redo) 작업을 통해 최근의 정상적인 데이터베이스로 회복한 후에 트랜잭션을 재실행할 수 있습니다.

검사점 기법(Check Point)
트랜잭션 중간에 검사점을 로그에 보관하여 트랜잭션 전체를 취소하지 않고 검사점까지 취소할 수 있는 기법

그림자 페이지 대체 기법(Shadow Paging)-로그가 필요없음
트랜잭션의 연산으로 갱신할 필요가 있을 때 복사본인 그림자 페이지를 보관하는 기법
트랜잭션을 취소할 때 그림자 페이지를 이용하여 회복.
로그(Log), 취소(Undo), 재시도(Redo)할 필요가 없습니다.



원자성 : 트랜잭션 연산은 DB에 모두 반영되어 Commit(완료)되든지 아니면 반영안되어 Rollback(복구)되어야 한다.
일관성 : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성있는 데이터베이스 상태로 변환한다.
독립성 : 둘 이상 트랜잭션이 동시 병행 실행될 경우 트랜잭션 실행 중 타 트랜잭션의 연산이 끼어들 수 없다.
지속성 : 성공적 완료된 트랜잭션 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.



분할 투명성(단편화) : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 사이트에 저장
위치 투명성 : 사용하려는 데이터의 저장장소를 명시가 필요하지 않음. 위치정보는 System Caltalog에 유지어야 함
지역사상 투명성 : 지역DBMS와 물리적 DB사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용가능
중복 투명성 : DB객체가 여러 사이트에 중복되어 있는지 알 필요가 없는 성질
장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 트랜잭션의 원자성유지
병행 투명성 : 다수 트랜잭션 동시수행시 결과의 일관성 유지, TImm Stamp, 분산2단계 Locking을 이용하여 구현

관계대수의 순수 관계 연산자 : select / project / join / division

데이터웨어하우스의 기본적인 OLAP(on-line analytical processing) 연산은 roll-up, slicing & dicing, drill-up & down, pivot, drill-through 등이 있습니다.



\1. 관계대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.
\2. 관계대수는 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션이고 결과도 릴레이션이다.
\3. 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.
\4. 대표적으로 순수 관계 연산자와 일반 집합 연산자가 있다.

관계해석이란?
\1. 관계 데이터 모델의 제안자인 코드가 수학에 가까운 기반을 두고 관계 데이터베이스를 위해 제안하여 탄생하였다.
\2. 관계해석은 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용한다.
\3. 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지닌다.
\4. 튜플 관계해석과 도메인 관계해석이 있다.
\5. 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등하며 관계대수로 표현한 식은 관계해석으로 표현할 수 있다.
\6. 질이어로 표현한다.



데이터 모델 개념: 현실 세계의 정보를 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델
데이터 모델 구성요소: 논리적 데이터 구조, 연산, 제약 조건
데이터 모델 절차: 개념적 데이터 모델>논리적 데이터 모델>물리적 데이터 모델



*요구조건 분석 / 명세 : 데이터베이스의 사용자, 사용목적, 사용범위, 제약조건 등에 대한 내용을 정리하고 명세서를 작성
*개념적 설계 : 정보를 구조화 하기 위해 추상적 개념으로 표현하는 과정으로 개념 스키마 모델리오가 트랜잭션 모델링을 병행하고, 요구조건 분석을 통해 DBMS 독립적인 E-R 다이어그램을 작성
*논리적 설계 : 자료를 컴퓨터가 이해할 수 있도록 특정 DBMS의 논리적 자료 구조로 변환하는 과정
*물리적 설계 : 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정
[해설작성자 : 분홍쨔응]

개념적 설계
:개념스키마 모델링 / 트렌젝션 모델링 / 독립적인 개념스키마설계 / E-R 다이어그램

논리적설계
:트렌젝션 인터페이스 설계 / 스키마 평가 및 정제 / 목표 DBMS에 맞는 논리스키마 설계 / 논리적구조의 데이터로 모델화

물리적설계
:저장구조 및 액세스 경로 설정 / 레코드 집중의 분석,설계 / 저장 레코드 양식 설계



인덱스 : 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 사용되는 것



\1. 범위 분할(range partitioning) : 분할 키 값이 범위 내에 있는지 여부로 구분한다.
\2. 목록 분할(list partitioning) : 값 목록에 파티션을 할당 분할 키 값을 그 목록에 비추어 파티션을 선택한다.
\3. 해시 분할(hash partitioning) : 해시 함수의 값에 따라 파티션에 포함할지 여주를 결정한다.
\4. 합성 분할(composite partitioning) : 상기 기술을 결합하는 것

수평분할
\- 하나의 테이블의 각 행을 다른 테이블에 분산시키는 것

라운드로빈 분할
\- 라운드로빈 분할은 파티션에 행의 고른 분포를 원할 때 사용한다. 그러나, 해시분할과 달리 분할 칼럼을 명시할 필요가 없다. 라운드 로빈 분할로 회전하면서 새로운 행이 파티션에 할당된다. 테이블은 기본키가 반드시 필요하진 않다.



일반 집합 연산자
\- UNION 합집합
\- INTERSECTION 교집합
\- DIFFERENCE 차집합
\- CARTESIAN PRODUCT 교차곱  // 차수는 더하고 카디널리티는 곱하고



