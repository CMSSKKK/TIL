# 03. 프로세스 관리

## 커널 주소 공간의 내용

* code
  * 커널코드
    * 시스템콜, 인터럽트 처리 코드
    * 자원 관리를 위한 코드
    * 편리한 서비스 제공을 위한 코드
* data(자료구조를 가지고 있음)
  * PCB --프로세스관리를 위한 자료구조(table)
  * CPU --cpu관리를 위한 자료구조(table)
  * memory --memory관리를 위한 자료구조(table)
  * disk -- disk관리를 위한 자료구조(table)
* stack
  * 프로세스의 커널 스택

## 사용자 프로그램이 사용하는 함수

* 함수

  * 사용자 정의함수
    * 자신의 프로그램에서 정의한 함수
  * 라이브러리 함수
    * 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
    * 자신의 프로그램의 실행 파일에 포함되어 있다

  * > 사용자 정의 함수와 라이브러리 함수는 프로세스의 코드 영역

  * 커널 함수

    * 운영체제 프로그램의 함수
    * 커널 함수의 호출 = 시스템 콜 

  * > 커널의 코드 영역



## 프로세스의 개념

* 프로세스의 문맥(context)

  > 과거에 cpu를 얼마나 사용했는가
  >
  > 메모리를 얼마나 차지했는가
  >
  > 파일은 몇 개나 열어뒀는가 등

  * CPU 수행 상태를 나타내는 하드웨어 문맥
    * Program Counter
    * 각종 register
  * 프로세스의 주소 공간
    * Code,data,stack
  * 프로세스 관련 커널 자료 구조
    * PCB
    * Kernel stack

## 프로세스의 상태

* Running

* Ready

* Blocked(wait, sleep)

  * CPU를 줘도 당장 instruction을 수행할 수 없는 상태

  * Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태

  * > 하드웨어(I/O) 처리가 시간이 오래걸려서 blocked상태가 되는 것만은 아니다.
    >
    > 프로세스간의 공유 데이터를 같이 사용하게 될 때에도 blcoked 상태가 될 수 있다.

* Suspended (stopped)

  * 외부적인 이유로 프로세스의 수행이 정지된 상태

  * 프로세스를 통째로 디스크에 swap out 된다

    예시) 사용자가 프로그램을 일시 정지시킨 경우 (break key) 

    시스템이 여러 이유로 프로세스를 잠시 중단시킴

    (메모리에 너무 많은 프로세스가 올라와 있을 때)

> * New : 프로세스가 생성중인 상태
> * Terminated : 수행이 끝난 상태
>
> * Blocked : 자신이 요청한 event가 만족되면 Ready
> * Suspended : 외부에서 resume해 주어야 Active



* Running 상태의 프로세스가 CPU 점유권을 내놓는 경우
  * Terminated
  * I/O or event wait
  * Timer interrupt



## PCB

* 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
* 다음의 구성 요소를 가진다 (구조체로 유지)
  * OS가 관리상 사용하는 정보
    * Process state, Process ID
    * scheduling information, priority
  * CPU 수행 관련 하드웨어 값
    * Program counter, registers
  * 메모리 관련
    * code, data, statck의 위치 정보
  * 파일 관련
    * Open file descriptors

## Context Switch

* CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
* CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행
  * CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
  * CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
* System call이나 Interrupt 발생시 반드시 context switch가 일어나는 것은 아님
  * context의 일부를 PCB에 저장하는 작업은 있다.



## 프로세스를 스케줄링하기 위한 큐

* Job queue
  * 현재 시스템 내에 있는 모든 프로세스의 집합
* Ready queue
  * 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
* Device queues
  * I/O 디바이스의 처리를 기다리는 프로세스의 집합
* 프로세스들은 각 큐들을 오가며 수행된다



> 프로세스 - fork a child
>
> 자식 프로세스를 만드는 것(자신을 복제하는 것과 같다.)



## 스케줄러

* Long-term scheduler (장기 스케줄러 or job scheduler)
  * 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정(admit)
  * 프로세스에 memory(및 각종 자원)을 주는 문제
  * degree of Multiprogramming을 제어
  * time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)
* **Short-term scheduler (단기 스케줄러 or CPU scheduler)**
  * 어떤 프로세스를 다음번에 running시킬지 결정
  * 프로세스에 CPU를 주는 문제
  * 충분히 빨라야 함 (millisecond 단위)
* **Medium-term scheduler (중기 스케줄러 or Swapper)**
  * 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
  * 프로세스에게서 memory를 뺏는 문제
  * Degree of Multiprogramming(현재 메모리에 있는 프로세스의 수) 제어

> 현대 운영체제는 Long-term sceduler가 없다.
>
> 프로세스를(new 상태없이) 바로 메모리에 ready 상태로 올라간다.
>
> 그래서 medium-term scheduler가 메모리를 빼앗는 역할을해서 메모리 관리를 한다.



## Thread

* Thread의 구성
  * Program counter
  * Register set
  * stack space
* Thread가 동료 Thread가 공유하는 부분(=task)
  * code section
  * data section
  * OS resources
* 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.

### 스레드의 장점

* 다중 스레도 구성된 테스크 구조에서는 하나의 서버 스레가 blocked(waiting) 상태인 동안에도 동일한 테스크 내의 다른 스레가 실행(running)되어 빠른 처리를 할 수 있다.
* 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다.
* 스레드를 사용하면 병렬성을 높일 수 있다. (다중코어 멀티프로그래밍)

* 응답성
* 자원 공유
* 경제적
  * 프로세스에 비해서 스레드의 생성과 CPU switching이 훨씬 경제적

> 운영체제가 스레드의 존재를 알고있는 경우, Kernel Threads
>
> 사용자가 멀티스레드로 프로그램을 구현했으나 운영체제가 하나의 프로세스로 보는 User Threads
>
> 리얼타임목적으로 사용하는 스레드도 있다.

## 프로세스 생성

* 부모 프로세스가 자식 프로세스를 생성
* 프로세스의 트리(계층 구조) 형성
* 프로세스는 자원을 필요로 함
  * 운영체제로부터 받는다.
  * 부모와 공유한다.
* 자원의 공유
  * 부모와 자식이 모든 자원을 공유하는 모델
  * 일부를 공유하는 모델
  * 전혀 공유하지 않는 모델
* 수행
  * 부모와 자식은 공존하며 수행되는 모델
  * 자식이 종료될 때까지 부모가 기다리는 (wait) 모델
* 주소 공간 (Address space)
  * 자식은 부모의 공간을 복사함
  * 자식은 그 공간에 새로운 프로그램을 올림
* 유닉스의 예
  * `fork()`시스템 콜이 새로운 프로세스를 생성
    * 부모를 그대로 복사
    * 주소 공간 할당
  * `fork()` 다음에 이어지는 `exec()`시스템 콜을 통해 새로운 프로그램을 메모리에 올림

## 프로세스 종료

* 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 (exit)
  * 자식이 부모에게 output data를 보냄 (via wait)
  * 프로세스의 각종 자원들이 운영체제에게 반납됨
* 부모 프로세스가 자식의 수행을 종료시킴 (abort)
  * 자식이 할당 자원의 한계치를 넘어섬
  * 자식에게 할당된 테스크가 더 이상 필요하지 않음
  * 부모가 종료(exit)하는 경우
    * 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
    * 단계적인 종료



> * 자바 스레드와 관련해서
>
> * 자바 스레드는 유저 스레드일까? 커널 스레드일까?
>
>   * 자바 스레드는 유저 스레드이다. 그렇다면 운영체제가 멀티스레드인지 모르기때문에 다대일로 매핑 되지 않을까?
>
>     * 그렇지 않다. 다대일의 방식의 다중 스레드 모델이 아닌 커널과 1대1로 매핑해주는 일대일 모델을 채택한다.
>     * 초기 자바에서는 다대일 모델을 사용했었다. (green thread)
>
>   * 그 이유는 JVM에서 찾을 수 있다.
>
>     * JVM은 일반적으로 호스트 운영체제에서 구현된다.
>     * 그리고 JVM은 하부 운영체제의 구현 세부 사항을 숨기고 자바 프로그램이 JVM을 지원하는 모든 플랫폼에서 작동할 수 있는 일관되고 추상적인 환경을 제공한다. (platform independent)
>     * 그에 따라 자바의 스레드는 하부 운영체제와 매핑이 되는 방법을 명시하지 않고, 각 JVM의 구현에 맡긴다(운영체제에 종속적)
>     * 그래서 자바의 스레드는 Windows 시스템에서는 windows API(스레드 라이브러리)를 통해 구현하고, UNIX, Linux, macOS 시스템에서는 Pthreads(스레드 라이브러리)를 통해서 구현된다.
>
>   * 그렇다면 왜 일대일 모델일까?
>
>     * 현대 시스템에서 처리 코어 수가 증가함에 따라서 커널 스레드 수를 제한하는 것의 중요성이 줄어들었다.
>     * 그래서 현대 운영체제의 다중 스레드 모델이 대부분 일대일 매핑이다.
>
>     
