## Multiple-Processor Scheduling

* CPU가 여러 개인 경우 스케줄링은 더욱 복잡해짐
* **Homogeneous processor**인 경우
  * Queue에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.
  * 반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해짐
* **Load sharing**
  * 일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요
  * 별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법
* **Symmetric Multiprocessing (SMP)**
  * 각 프로세서가 각자 알아서 스케줄링 결정
* **Asymmetric multiprocessing**
  * 하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름



## Algorithm Evaluation

### Queueing models

* 확률 분포로 주어지는 arrival rate와 service rate 등을 통해 각종 performance index 값을 계산

### Implementation & Measurement

* 실제 시스템에 알고리즘을 구현하여 실제 작업(workload)에 대해서 성능을 측정 비교

### Simulation

* 알고리즘을 모의 프로그램으로 작성후 trace를 입력으로 하여 결과 비교





# 05. 병행 제어 1



### OS에서 race condition은 언제 발생하는가?

1. kernel 수행 중 인터럽트 발생 시
2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
3. Multiprocessor에서 shared memory내의 kernel data

## Process Synchronization 문제

* 공유 데이터의 동시 접근은 데엍의 불일치 문제를 발생시킬 수 있다.
* 일관성 유지를 위해서는 협력 프로세스간의 실행 순서를 정해주는 메커니즘 필요

### Race condition

* 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
* 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
* race condition을 막기 위해서는 concurrent process는 동기화되어야 한다.

### The Critical-Section Problem

* n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우
* 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재

**Problem** 

* 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.

