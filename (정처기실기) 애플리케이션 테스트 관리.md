# 애플리케이션 테스트 관리

* 살충제 패러독스
  * 동일한 테스트 케이스로 반복 실행하면 결함을 발견할 수 없으므로 주기적으로 테스트 케이스를 리뷰하고 개선해야 한다.
* 오류-부재의 궤변
  * 요구사항을 충족시키지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없다.
* 소프트웨어 테스트 산출물
  * 테스트 케이스 : 테스트를 위한 설계 산출물로, 응용 소프트웨어가 사용자의 요구사항을 준수하는지 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서
  * 테스트 시나리오 : 테스트 수행을 위한 여러 개의 테스트 케이스의 집합으로 테스트 케이스의 동작순서를 기술한 문서이며, 테스트를 위한 절차를 명세한 문서
  * 테스트 오라클 : 테스트의 결과가 참인지 거짓인지를 판단하기 위해 사전에 정의된 참값을 입력하여 비교하는 기법
* 정적 테스트와 동적 테스트의 차이점
  * 정적 테스트는 프로그램을 실행하지 않고 테스트하고 동적 테스트는 프로그램을 실행하면서 오류를 찾는다.
* 화이트박스 테스트
  * 프로그램 코드를 보면서 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인한다.
  * 테스트 방법은 구문 기반, 결정 기반, 조건 기반, 조건결정 기반, 변경조건 결정 기반, 멀티조건 기반 커버리지 테스트 등이 있다.
* 소프트웨어 개발 단계에 따른 테스트 순서
  1. 단위 테스트
  2. 통합 테스트
  3. 시스템 테스트
  4. 인수 테스트
* 상향식 통합 테스트의 단계
  1. 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합
  2. 각 통합된 클러스터 단위를 테스트
  3. 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 **드라이버**를 작성
  4. **드라이버**는 실제 모듈 또는 컴포넌트로 대체
* 스텁 (Stub)
  * 하향식 통합 테스트에서 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
* 애플리케이션 테스트 프로세스의 단계
  1. 테스트 계획
  2. 테스트 분석
  3. 테스트 케이스 작성
  4. 테스트 실행
  5. 테스트 결과 분석
* 정적 분석 도구
  * 프로그램을 실제로 실행해 보지 않고 분석하는 방법
  * 대부분의 경우 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위해 사용
  * 테스트를 수행하는 사람이 작성된 소스 코드에 대해 이해하고 있어야만 분석이 가능
* 클린 코드
  * 잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드
*  애플리케이션 성능
  * 사용자가 요구한 기능에 대해 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도
* 애플리케이션 성능을 측정하기 위한 지표
  * 처리량 : 주어진 시간에 처리할 수 있는 트랜잭션의 수
  * 응답 시간 : 사용자 입력이 끝난 후, APP의 응답 출력이 개시될 때까지의 시간
  * 경과 시간 : 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때까지 걸리는 시간
  * 자원 사용률 : 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

----------

* 요르돈의 법칙(눈덩이 법칙) : 개발 초기에 테스팅하지 않으면 비용이 커진다
* 파레토 법칙(결함 집중) : 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다.
* 화이트박스 테스트 유형
  * 구문 커버리지 : 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
  * 결정 커버리지 : 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행
  * 조건 커버리지 : 결정 포인트 내의 각 개별 조건식이 적어도 한번은 참과 거짓의 결과가 되도록 수행
  * 조건/결정 커버리지 : 전체 조건식 + 개별 조건식
  * 변경 조건/결정 커버리지 : 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함
  * 다중 조건 커버리지 : 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
  * 기본 경로 커버리지 : 수행 가능한 모든 경로를 테스트, 맥케이브 순환 복잡도 - 맥케이브 복잡도 : 간선 수 - 노드 수 + 2
  * 제어 흐름 테스트 : 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직 테스트
  * 데이터 흐름 테스트 : 제어 흐름 그래프에 사용현황 추가
* 블랙박스 테스트 유형
  * 동등 분할 테스트 : 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출해 테스트
  * 경곗값 분석 테스트 : 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트 하는 기법
  * 결정 테이블 테스트 : 요구사항의 논리와 발생조건을 테이블 형태로 나열해, 조건과 행위를 모두 조합해 테스트
  * 상태 전이 테스트 :  어느 한 상태에서 다른 상태로 전이 되는 경우의 수를 수행하는 테스트
  * 유스케이스 테스트 : 프로세스 흐름을 기반으로 테스트 케이스를 명세화해 수행하는 테스트
  * 분류 트리 테스트 : SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스 설계해 테스트
  * 페어와이즈 테스트 : 테스트 데이터 값들 간에 최소한 한 번씩 조합하는 방식
  * 원인-결과 그래프 테스트 : 그래프를 활용해 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석
  * 비교 테스트 : 여러 버전의 프로그램에 같은 입력값을 넣어 비교해 테스트
* 테스트 시각에 따른 분류
  * 검증 : 소프트웨어 개발 과정 테스트, 개발자 혹은 시험자 시각
  * 확인 : 소프트웨어 결과 테스트, 사용자 시각
* 테스트 목적에 따른 분류
  * 회복 테스트
  * 안전 테스트
  * 성능 테스트
  * 구조 테스트
  * 회귀 테스트
  * 병행 테스트
* 테스트 하네스
  * 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말하며, 단위 또는 모듈 테스트에 사용화기 위해 코드 개발자가 작성한다.
* 정적 분석 도구
  * pmd : 자바 및 타언어 소스 코드에 대한 버그, 데드코드 분석
  * cppcheck : C/C++ 코드에 대한 메모리 누수, 오버플로우 등 문제 분석
  * checkstyle : 자바 코드에 대한 코딩 표준 검사 도구
* 동적 분석 도구
  * Avalanche : Valgrind, STP 기반 소프트웨어 에러 및 취약점 동적 분석 도구
  * Valgrind : 자동화된 메모리 및 스레드 결함 발견 분석 도구
* 리팩토링 : 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완해 가용성 및 가독성을 높이는 기법

----------

